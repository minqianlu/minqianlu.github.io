"use strict";(self.webpackChunktest_site=self.webpackChunktest_site||[]).push([[4435],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=u(n),h=r,y=c["".concat(l,".").concat(h)]||c[h]||p[h]||a;return n?o.createElement(y,s(s({ref:t},d),{},{components:n})):o.createElement(y,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2378:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const a={sidebar_label:"Fungible Token Drops",sidebar_position:4},s="Fungible Token Drops",i={unversionedId:"Github ReadMe/Types of Drops/ftdrops",id:"version-1.1/Github ReadMe/Types of Drops/ftdrops",isDocsHomePage:!1,title:"Fungible Token Drops",description:"A Fungible Token drop is also a light wrapper around the simple drop. It works very similarly to how its NFT",source:"@site/versioned_docs/version-1.1/Github ReadMe/Types of Drops/ftdrops.md",sourceDirName:"Github ReadMe/Types of Drops",slug:"/Github ReadMe/Types of Drops/ftdrops",permalink:"/Github ReadMe/Types of Drops/ftdrops",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/versioned_docs/version-1.1/Github ReadMe/Types of Drops/ftdrops.md",tags:[],version:"1.1",sidebarPosition:4,frontMatter:{sidebar_label:"Fungible Token Drops",sidebar_position:4},sidebar:"version-1.1/tutorialSidebar",previous:{title:"Non Fungible Token Drops",permalink:"/Github ReadMe/Types of Drops/nftdrops"},next:{title:"Function Call Drops",permalink:"/Github ReadMe/Types of Drops/fcdrops"}},l=[{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"FT Config",id:"ft-config",children:[]},{value:"Use Cases",id:"use-cases",children:[{value:"Recurring Payments",id:"recurring-payments",children:[]},{value:"Backend Servers",id:"backend-servers",children:[]},{value:"Creating a Wallet with FTs",id:"creating-a-wallet-with-fts",children:[]}]}],u={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"fungible-token-drops"},"Fungible Token Drops"),(0,r.kt)("p",null,"A Fungible Token drop is also a light wrapper around the simple drop. It works very similarly to how its NFT\ncounterpart does. First, you'll need to create the drop and then you can fund it with assets and register\nkey uses."),(0,r.kt)("p",null,"You can preload a drop with as many FTs as you'd like even if you don't have the keys yet. This will spike the\n",(0,r.kt)("inlineCode",{parentName:"p"},"registered_uses"),' and then you can create keys and slowly eat away from this "total supply" overtime. If the\ndrop runs out, you can send it more FTs to top up. All the keys in the FT drop will share from this supply\nand everytime a key is used, the ',(0,r.kt)("inlineCode",{parentName:"p"},"registered_uses"),' will decrement and the "total supply" will get smaller.'),(0,r.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,r.kt)("p",null,"As mentioned in the NFT section, every drop has a field known as ",(0,r.kt)("inlineCode",{parentName:"p"},"registered_uses"),". This tells the contract\nhow many uses the drop has across all its keys. For simple drops, this field doesn't matter since all the uses\nare paid for up-front when the drop is created or when keys are added. With FT drops, however,\nthere is a 2 step process:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Firstly, the drop is created and all the $NEAR required is pre-paid for. This is the same as\nsimple drops, however, the ",(0,r.kt)("inlineCode",{parentName:"li"},"registered_uses")," are set to 0."),(0,r.kt)("li",{parentName:"ul"},"Once the drop is created, the owner must send the contract the FTs in order for keys to be\nusable. This process is done through the ",(0,r.kt)("inlineCode",{parentName:"li"},"ft_transfer_call")," workflow baked into the FT standards.\nIt's up to the owner to facilitate this process.")),(0,r.kt)("h2",{id:"ft-config"},"FT Config"),(0,r.kt)("p",null,"Along with the default global configurations for drops, if you'd like to create a FT drop,\nyou must specify the following pieces of information when the drop is created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct FTDataConfig {\n    /// The contract that the FTs live on.\n    pub contract_id: AccountId,\n    /// The account ID that will be sending the FTs to the contract.\n    pub sender_id: AccountId,\n    /// How many FTs should the contract send *each time* a key is used.\n    pub balance_per_use: U128,\n}\n")),(0,r.kt)("p",null,"By specifying this information, the drop is locked into only accepting FTs coming from the sender and contract. While\nyou can send as many FTs as you'd like and can over-pay, you ",(0,r.kt)("em",{parentName:"p"},"must")," send at ",(0,r.kt)("strong",{parentName:"p"},"least")," enough FTs in one call to cover\n1 use. As an example, if a drop is created such that 10 FTs will be sent when a key is used, you must send ",(0,r.kt)("strong",{parentName:"p"},"at least 10"),"\nand cannot break it up into separate calls where you send 5 one time and 5 another."),(0,r.kt)("h2",{id:"use-cases"},"Use Cases"),(0,r.kt)("p",null,"FT drops have some awesome flexibility due to the fact that they support all the functionalities of the Simple drops, just with\nmore use-cases and possibilities. Let's look at some use cases to see how fungible token drops can be used."),(0,r.kt)("h3",{id:"recurring-payments"},"Recurring Payments"),(0,r.kt)("p",null,"Recurring payments are quite a common situation. Let's say you need to send someone $50 USDC every week. You\ncould create a key with 5 claims that has a claim_interval` of 1 week. You would then pre-load maybe the\nfirst week's deposit of $50 USDC and register 1 use or you could send $500 USDC for the first 10 weeks. At that\npoint, you would simply hand over the key to the user and they can claim once a week."),(0,r.kt)("h3",{id:"backend-servers"},"Backend Servers"),(0,r.kt)("p",null,"Taking the recurring payments problem to another level, imagine that instead of leaving the claims up to the\ncontractor, you wanted to automatically pay them through a backend server. They would give you their NEAR account\nand you would send them FTs. The problem is that you don't want to expose your full access key in the server.\nBy creating a FT drop, you can store ",(0,r.kt)("strong",{parentName:"p"},"only the function call access key")," created by Keypom in the server.\nYour backend would them use the key to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"claim")," function and pass in the user's account ID to send\nthem the FTs."),(0,r.kt)("h3",{id:"creating-a-wallet-with-fts"},"Creating a Wallet with FTs"),(0,r.kt)("p",null,"Another awesome use-case is to allow users to be onboarded onto NEAR and ",(0,r.kt)("strong",{parentName:"p"},"also")," receive FTs. As an example,\nYou could do a promotion where you're giving away $10 USDC to the first 100 users that sign up to your mailing\nlist. You can also give away QR codes at events that contain a new fungible token that you're launching. You can\nsimply create a FT drop and pre-load it with the FT of your choice. In addition, you can give it 0.02 $NEAR for\nnew wallets that are created."),(0,r.kt)("p",null,"You can pair this with setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"on_claim_refund_deposit")," flag to true which would make it so that if anyone claims\nthe fungible tokens and they ",(0,r.kt)("em",{parentName:"p"},"already have a wallet"),", it will automatically refund you the 0.02 $NEAR. That money should\nonly be used for the creation of new wallets. Since your focus is on the fungible tokens, you don't want to ",(0,r.kt)("strong",{parentName:"p"},"force users"),"\nto create a new wallet if they have one already by specifying the claim permission to be ",(0,r.kt)("inlineCode",{parentName:"p"},"CreateAccountAndClaim")," but instead,\nyou want to be refunded in case they do."))}d.isMDXComponent=!0}}]);