"use strict";(self.webpackChunktest_site=self.webpackChunktest_site||[]).push([[2108],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>c});var s=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,s)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,s,n=function(e,t){if(null==e)return{};var a,s,n={},o=Object.keys(e);for(s=0;s<o.length;s++)a=o[s],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)a=o[s],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var h=s.createContext({}),l=function(e){var t=s.useContext(h),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=l(e.components);return s.createElement(h.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,h=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(a),c=n,k=u["".concat(h,".").concat(c)]||u[c]||p[c]||o;return a?s.createElement(k,r(r({ref:t},d),{},{components:a})):s.createElement(k,r({ref:t},d))}));function c(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=u;var i={};for(var h in t)hasOwnProperty.call(t,h)&&(i[h]=t[h]);i.originalType=e,i.mdxType="string"==typeof e?e:n,r[1]=i;for(var l=2;l<o;l++)r[l]=a[l];return s.createElement.apply(null,r)}return s.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5011:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});var s=a(7462),n=(a(7294),a(3905));const o={sidebar_label:"Password Protected Keys",sidebar_position:3},r="Password Protected Keys",i={unversionedId:"Github ReadMe/passwordprotect",id:"version-1.0/Github ReadMe/passwordprotect",isDocsHomePage:!1,title:"Password Protected Keys",description:"Password protecting key uses is an extremely powerful feature that can unlock many use-cases. Keypom has baked flexibility and customization",source:"@site/versioned_docs/version-1.0/Github ReadMe/passwordprotect.md",sourceDirName:"Github ReadMe",slug:"/Github ReadMe/passwordprotect",permalink:"/1.0/Github ReadMe/passwordprotect",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/versioned_docs/version-1.0/Github ReadMe/passwordprotect.md",tags:[],version:"1.0",sidebarPosition:3,frontMatter:{sidebar_label:"Password Protected Keys",sidebar_position:3},sidebar:"version-1.0/tutorialSidebar",previous:{title:"Function Call Drops",permalink:"/1.0/Github ReadMe/Types of Drops/fcdrops"},next:{title:"Costs",permalink:"/1.0/Github ReadMe/costs"}},h=[{value:"How Does It Work?",id:"how-does-it-work",children:[]},{value:"What is Stored On-Chain?",id:"what-is-stored-on-chain",children:[]},{value:"Adding Your First Password",id:"adding-your-first-password",children:[]},{value:"Key A",id:"key-a",children:[]},{value:"Key D",id:"key-d",children:[]},{value:"Key B",id:"key-b",children:[{value:"Ticketing and POAPs",id:"ticketing-and-poaps",children:[]},{value:"Marketing and Engagement",id:"marketing-and-engagement",children:[]}]},{value:"dApp Free Trials for Users",id:"dapp-free-trials-for-users",children:[]}],l={toc:h};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,s.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"password-protected-keys"},"Password Protected Keys"),(0,n.kt)("p",null,"Password protecting key uses is an extremely powerful feature that can unlock many use-cases. Keypom has baked flexibility and customization\ninto the contract such that almost all use-cases involving password protection can be accomplished. Whenever a key is added to a drop, it can\nhave a unique password for each individual use, or it can one password for all uses in general."),(0,n.kt)("h2",{id:"how-does-it-work"},"How Does It Work?"),(0,n.kt)("p",null,"The Keypom implementation has been carefully designed so that users can't look at the NEAR Explorer to view what was passed into the contract\neither when the drop was created or when a key was used to try and copy those passwords. We also want passwords to be unique across keys so that\nif you know the password for 1 key, it doesn't work on a different key. In order to accomplish this, we use the concept of hashing."),(0,n.kt)("p",null,"Imagine you have a drop with 2 keys and you want to password protect each key. Rather than forcing the drop funder to input a unique password for\neach key and having them remember each one, we can have them input a single ",(0,n.kt)("strong",{parentName:"p"},"base password")," and derive unique passwords from it that are paired\nwith the key's public key."),(0,n.kt)("p",null,"This is the most scalable option as it allows the drop funder to only need to remember 1 password and they can derive all the other ones using the\nhashing algorithm and public key."),(0,n.kt)("p",null,"In the above scenario, let's say the funder inputs the base password as ",(0,n.kt)("inlineCode",{parentName:"p"},"mypassword1"),". If a user wanted to claim the first key, they would need to input\ninto the contract:"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},'hash("mypassword1" + key1_public_key)')),(0,n.kt)("p",null,"The funder would need to give the user this hash somehow (such as embedding it into the link or having an app that can derive it). It's important to note\nthat the funder should probably ",(0,n.kt)("strong",{parentName:"p"},"NOT")," give them the base password otherwise the user could derive the passwords for all other keys (assuming those keys have\nthe same base password)."),(0,n.kt)("h2",{id:"what-is-stored-on-chain"},"What is Stored On-Chain?"),(0,n.kt)("p",null,"How does Keypom verify that the user passed in the correct password? If the funder were to simply pass in ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("mypassword1" + key1_public_key)')," into the\ncontract as an argument when the key is created, users could just look at the NEAR Explorer and copy that value. "),(0,n.kt)("p",null,"Instead, the funder needs to pass in a double hash when the key is created: ",(0,n.kt)("inlineCode",{parentName:"p"},'hash(hash("mypassword1" + key1_public_key))'),". "),(0,n.kt)("p",null,"This is the value that is stored on-chain and when the user tries to claim the key, they would pass in just the single hash: ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("mypassword1" + key1_public_key)'),".",(0,n.kt)("br",{parentName:"p"}),"\n","The contract would then compute ",(0,n.kt)("inlineCode",{parentName:"p"},'hash(hash("mypassword1" + key1_public_key))')," and compare it to the value stored on-chain. If they match, the key is claimed."),(0,n.kt)("p",null,"Using this method, the base password is not exposed to the user, nobody can look on-chain or at the NEAR explorer and derive the password, and the password is unique\nacross multiple keys."),(0,n.kt)("h1",{id:"passwords-per-key-use"},"Passwords Per Key Use"),(0,n.kt)("p",null,"Unlike the passwords per key which is the same for all uses of a key, the drop creator can specify a password for each individual key use. This password follows\nthe same pattern as the passwords per key in that the funder inputs a ",(0,n.kt)("inlineCode",{parentName:"p"},"hash(hash(SOMETHING))")," and then the user would input ",(0,n.kt)("inlineCode",{parentName:"p"},"hash(SOMETHING)")," and the contract\nwould hash this and compare it to the value stored on-chain."),(0,n.kt)("p",null,"The difference is that each individual key use can have a different value stored on-chain such that the user can be forced to input a different hash each time.\nThis ",(0,n.kt)("inlineCode",{parentName:"p"},"SOMETHING")," that is hashed can be similar to the global password per key example but this time, the desired key use is added: ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("mypassword1" + key1_public_key + use_number)')),(0,n.kt)("p",null,"In order to pass in the passwords per use, a new data structure is introduced so you only need to pass in passwords for the uses that have them. This is known as the\n",(0,n.kt)("inlineCode",{parentName:"p"},"JsonPasswordForUse")," and is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct JsonPasswordForUse {\n    /// What is the password for this use (such as `hash("mypassword1" + key1_public_key + use_number)`)\n    pub pw: String,\n    /// Which use does this pertain to\n    /// This is *zero indexed*. The first use starts at 0.\n    pub key_use: u64\n}\n')),(0,n.kt)("h2",{id:"adding-your-first-password"},"Adding Your First Password"),(0,n.kt)("p",null,"Whenever keys are added to Keypom, if there's passwords involved, they must be passed in using the following format. "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"passwords_per_use: Option<Vec<Option<Vec<JsonPasswordForUse>>>>,\npasswords_per_key: Option<Vec<Option<String>>>,\n")),(0,n.kt)("p",null,"Each key that is being added either has a password, or doesn't. This is through the ",(0,n.kt)("inlineCode",{parentName:"p"},"Vec<Option<>"),". This vector ",(0,n.kt)("strong",{parentName:"p"},"MUST")," be the same length as the number of keys created.This doesn't\nmean that every key needs a password, but the Vector must be the same length as the keys."),(0,n.kt)("p",null,"As an example, if you wanted to add 3 keys to a drop and wanted only the first and last key to have a password_per_key, you would pass in:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"passwords_per_key: Some(vec![Some(hash(hash(STUFF))), None, Some(hash(hash(STUFF2)))])\n")),(0,n.kt)("h1",{id:"complex-example"},"Complex Example"),(0,n.kt)("p",null,"To help solidify the concept of password protected keys, let's go through a complex example. Imagine Alice created a drop with a ",(0,n.kt)("inlineCode",{parentName:"p"},"uses_per_key")," of 3.\nShe wants to create 4 keys: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Key A: No password protection."),(0,n.kt)("li",{parentName:"ul"},"Key B: Password for uses 1 and 2."),(0,n.kt)("li",{parentName:"ul"},"Key C: Password for use 1 only."),(0,n.kt)("li",{parentName:"ul"},"Key D: Password that doesn't depend on the use.")),(0,n.kt)("p",null,"In this case, for Keys B and C, they will have the same base password but Alice wants to switch things up and have a different base password for Key D.\nWhen these keys are added on-chain, the ",(0,n.kt)("inlineCode",{parentName:"p"},"passwords_per_key")," will be passed in as such:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'passwords_per_key: Some(vec![\n    None, // Key A\n    None, // Key B\n    None, // Key C\n    // Key D\n    Some(\n        hash(hash("key_d_base_password" + key_d_public_key))\n    ), \n]),\n')),(0,n.kt)("p",null,"The passwords for Key B and Key C will be passed in as such:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'passwords_per_key: Some(vec![\n    None, // Key A\n\n    // Key B\n    vec![\n        {\n            pw: hash(hash("keys_bc_base_password" + key_b_public_key + "0")),\n            key_use: 0\n        },\n        {\n            pw: hash(hash("keys_bc_base_password" + key_b_public_key + "1")),\n            key_use: 1\n        }\n    ]\n\n    // Key C\n    vec![\n        {\n            pw: hash(hash("keys_bc_base_password" + key_c_public_key + "0")),\n            key_use: 0\n        }\n    ]\n\n    None // Key D\n]),\n')),(0,n.kt)("p",null,"The drop funder would then give the keys out to people:"),(0,n.kt)("h2",{id:"key-a"},"Key A"),(0,n.kt)("p",null,"Alice gives Bob Key A and he would be able to claim it 3 times with no password required."),(0,n.kt)("h2",{id:"key-d"},"Key D"),(0,n.kt)("p",null,"Alice gives Charlie Key D and he would be able to claim it 3 times with the hashed global key password: ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("key_d_base_password" + key_d_public_key)'),".\nWhen Charlie claims the key, he would input the password ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("key_d_base_password" + key_d_public_key)')," and the contract would hash that and check to see\nif it matches what is stored on-chain (which it does)."),(0,n.kt)("p",null,"If anyone tried to look at what Charlie passes in through the explorer, it wouldn't work since his hash contains the public key for key D and as such it is only\nvalid for Key D."),(0,n.kt)("p",null,"Similarly, if Charlie tried to look at the explorer when Alice created the keys and attempted to pass in ",(0,n.kt)("inlineCode",{parentName:"p"},'hash(hash("key_d_base_password" + key_d_public_key))'),",\nthe contract would attempt to hash this and it would NOT match up with what's in the storage."),(0,n.kt)("h2",{id:"key-b"},"Key B"),(0,n.kt)("p",null,"Alice gives Eve Key B and she would need a password for claim 1 and 2. For the first claim, she needs to pass in: ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("keys_bc_base_password" + key_b_public_key + "0")'),".\nThe contract would then check and see if the hashed version of this matches up with what's stored on-chain for that use."),(0,n.kt)("p",null,'The second time Eve uses the key, she needs to pass in hash("keys_bc_base_password" + key_b_public_key + "1") and the same check is done.'),(0,n.kt)("p",null,"If Eve tries to pass in ",(0,n.kt)("inlineCode",{parentName:"p"},'hash("keys_bc_base_password" + key_b_public_key + "0")')," for the second key use, the contract would hash it and check:"),(0,n.kt)("p",null,'hash(hash("keys_bc_base_password" + key_b_public_key + "0")) == hash(hash("keys_bc_base_password" + key_b_public_key + "1"))'),(0,n.kt)("p",null,"Which is incorrect and the key would not be claimed."),(0,n.kt)("p",null,"Once Eve claims the key 2 times, the last claim is not password protected and she's free to claim it."),(0,n.kt)("p",null,"Key C is similar to Key B except that it only has 1 password for the first use."),(0,n.kt)("h1",{id:"use-cases"},"Use-Cases"),(0,n.kt)("p",null,"Password protecting key uses is a true game changer for a lot of use-cases spanning from ticketing to simple marketing and engagement."),(0,n.kt)("h3",{id:"ticketing-and-poaps"},"Ticketing and POAPs"),(0,n.kt)("p",null,"Imagine you had an event and wanted to give out exclusive POAPs to people that came. You didn't want to force users to: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Have a NEAR wallet"),(0,n.kt)("li",{parentName:"ul"},"Have wifi at the door."),(0,n.kt)("li",{parentName:"ul"},"Burn NFTs or tokens to get into the event.")),(0,n.kt)("p",null,"The important thing to note is that by using password protected key uses, you can ",(0,n.kt)("strong",{parentName:"p"},"GUARANTEE")," that anyone that received a POAP had to\n",(0,n.kt)("strong",{parentName:"p"},"PHYSICALLY")," show up to the event. This is because the POAP would be guarded by a password."),(0,n.kt)("p",null,"You could create a ticketing event using Keypom as outlined in the ",(0,n.kt)("a",{parentName:"p",href:"#nft-ticketing"},"Ticketing")," section and have a key with 2 uses. The first use\nwould be password protected and the second use is not. The first use will get you through the door and into the event and the second\ncontains the exclusive POAP and can onboard you. This means that anyone with the ticket, or key, can only receive the POAP if they know the password."),(0,n.kt)("p",null,"You can have a scanner app that would scan people's tickets (tickets are just the private key). In this scanner app, the ",(0,n.kt)("em",{parentName:"p"},"base password")," is stored and\nwhenever the ticket is scanned, the public key is taken and the following hash is created:"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"hash(base password + public key)")),(0,n.kt)("p",null,"This hash is then used to claim a use of the key and you will be let into the party. The scanner app can deterministically generate all the\nnecessary hashes for all the tickets by simply scanning the QR code (which has the private key exposed). The tickets are worthless unless\nyou actually show up to the event and are scanned."),(0,n.kt)("p",null,"Once you're scanned, you can refresh your ticket page and the use the second key claim which is not password protected. This use contains the\nexclusive POAP and you can onboard onto NEAR."),(0,n.kt)("h3",{id:"marketing-and-engagement"},"Marketing and Engagement"),(0,n.kt)("p",null,"Let's say that you're at an event and want people to show up to your talks and learn about your project. You can have a scanner app similar to the\none mentioned in the ticketing scenario that derives the password for any use on any key."),(0,n.kt)("p",null,"At the beginning of the event, you can give out a bunch of keys that have progressively increasing rewards gated by a password. At the end, the last\nkey use contains a special reward that is only unlocked if the user has claimed all the previous key uses."),(0,n.kt)("p",null,"In order for these uses to be unlocked, People must show up to your talks and get scanned. The scanner will derive the necessary password and unlock\nthe rewards. Users will only get the exclusive reward if they come to ALL your talks."),(0,n.kt)("p",null,"This idea can be further expanded outside the physical realm to boost engagement on your websites as an example:"),(0,n.kt)("p",null,"You want users to interact with new features of your site or join your mailing list."),(0,n.kt)("p",null,"You can have links where uses are ONLY unlocked if the user interacts with special parts of your site such as buying a new NFT or joining your mailing list\nor clicking an easter egg button on your site etc."),(0,n.kt)("h2",{id:"dapp-free-trials-for-users"},"dApp Free Trials for Users"),(0,n.kt)("p",null,"In the upcoming Keypom V2.0, dApps will be able to integrate the Keypom wallet selector plugging to allow for free trials for their users. One of the biggest pain-points with Web3 at the moment is the fact that users need to fund wallets ",(0,n.kt)("em",{parentName:"p"},"before")," they interact with a dApp."),(0,n.kt)("p",null,"In Web2, a user can find value in an application by using it before they go through the messy onboarding process. Why can't Web3 be the same?"),(0,n.kt)("p",null,"Keypom will allow apps to create links that will automatically sign users into their applications and give them a free trial of the app. The user will be able to interact with things, spend $NEAR, sign transactions and gather assets through the trial. A unique feature of this is that the user will ",(0,n.kt)("em",{parentName:"p"},"never be redirected to the NEAR wallet")," to approve transactions."),(0,n.kt)("p",null,"Keypom will provide a seamless user experience where users can find value in applications. Once the free trial is over and users have collected assets / $NEAR through interacting with the dApp, they can ",(0,n.kt)("em",{parentName:"p"},"THEN")," choose to onboard."),(0,n.kt)("p",null,"With Keypom's technology, users will be locked into only interacting with the dApp specified in the link. Users can't rug the application and steal the $NEAR embedded in the link. The funds are allocated for 1 thing and 1 thing only: free trials of that one specific dApp."),(0,n.kt)("p",{align:"center"},(0,n.kt)("img",{src:"/static/img/trial_accounts.png",width:"65%",height:"65%",alt:"traial accounts"})))}d.isMDXComponent=!0}}]);